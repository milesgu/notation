之前编译原理课程设计的概要设计展示的时候，一直以为类是可以嵌套定义的，实际上这么说不完全正确。
例如，
<pre>
class B;
class A{
      public:
          B b;
};
class B{
      public:
          A a;
};
</pre>

在A对象中要开辟一块属于B的空间，而B中又有A的空间，是一个逻辑错误，无法实现的，两个类都无从得知需要给对方分配多少空间。

我们可以将class A中关于class B的定义改成指针即可。（在同一平台、同一编译系统中，数据结构的指针所占用空间的大小都是一样的，没有任何文档表名数据指针和函数指针的大小是一样的，但是实际上这两者一般也都是一样的）。但是只将class B中的class A的定义改成指针是没有作用的，因为这样class A的定义中仍无法确定class B的大小。

所以如果两个类的定义互相嵌套，则肯定至少会有一个是指针。

<pre>
class B;

class A{
public:
    B *b;
    int num;
};

class B{
public:
    A *a;
    int num;
};
</pre>

像上面这样，两个类的定义写在一个文件中，是可以编译通过的，但是如果我们写在两个文件中呢？

<pre>
//A.h
#pragma once
#include "B.h"

class A{
public:
    B *b;
};

//B.h
#pragma once
#include "A.h"

class B{
    public:
        A* a;
};

//main.cpp
#include "A.h"
int main(){
    class A a;
}
</pre>

首先为了防止头文件无限递归嵌套包含，两个头文件都加上了#pragma once。但是这样仍无法编译通过。我们观察到这两个头文件中，都没有前向声明，而之前我们写在一个文件中的例子是在class A的定义之前包含了一个class B的前向声明的。那我们就在A.h的前部加上class B的前向声明，但是仍无法编译通过。这个时候我们需要从预编译的角度一步一步考虑。

首先在main.cpp中，#include "A.h"，所以我们把A.h的内容搬到main.cpp中；然后A.h中又#include "B.h"，所以又需要把B.h的内容搬进来（由于两个头文件均写了#pragma once，所以B.h的#include "A.h"实际上是不起作用的），这个时候我们发现class B在定义的时候，class A还未定义，因此我们需要前向声明class A。

所以我们得出结论，在这种情况下，至少需要在B.h中加入class A的前向声明。但实际上main.cpp中可以定义class B b，在这种情况下进行一次推导，得到的结论显然是我们需要在A.h中加入class B的前向声明。所以在这种互相嵌套定义的情况下，每个类的.h文件的前部，都需要加入另一个类的前向声明。

实际上，由于上例中嵌套定义涉及的都是指针，编译器无需类的具体定义就可确定指针的大小，所以头文件的互相包含可以去掉。

总的来说，只有当一个头文件中用到了另一个类的成员变量或方法；或者以静态方式（非指针）定义，编译器需要知道另一个类的大小时，才需要包含头文件，其它情况能不包含就不要包含。

###类的前向声明和头文件的包含的取舍
注意头文件的包含在预编译的时候是非常耗时间的。
有两点原则，
第一个原则: **如果可以不包含头文件，那就不要包含,这时候前置声明可以解决问题,如果使用的仅仅是一个类的指针，没有使用这个类的具体对象（非指针），也没有访问到类的具体成员，那么前置声明就可以了,因为指针这一数据类型的大小是特定的，编译器可以获知。**

第二个原则: **尽量在CPP文件中包含头文件，H文件中包含前向声明**。假设类A的一个成员是是一个指向类B的指针，在类A的头文件中使用了类B的前置声明并编译成功，那么在A的实现中我们需要访问B的具体成员，因此需要包含头文件，那么我们应该在类A的实现部分(CPP文件)包含类B的头文件而非声明部分(H文件)。

###C++嵌套类的使用方法
在一个类的内部定义另一个类，我们称之为嵌套类（nested class），或者嵌套类型。之所以引入这样一个嵌套类，往往是因为外围类需要使用嵌套类对象作为底层实现，并且**该嵌套类只用于外围类的实现**，且同时可以对用户隐藏该底层实现。

虽然嵌套类在外围类内部定义，但它是一个独立的类，基本上与外围类不相关。它的成员不属于外围类，同样，外围类的成员也不属于该嵌套类。嵌套类的出现只是告诉外围类有一个这样的类型成员供外围类使用。并且，外围类对嵌套类成员的访问没有任何特权，嵌套类对外围类成员的访问也同样如此，它们都遵循普通类所具有的标号访问控制。

**若不在嵌套类内部定义其成员，则其定义只能写到与外围类相同的作用域中，且要用外围类进行限定，不能把定义写在外围类中。例如，嵌套类的静态成员就是这样的一个例子。**

前面说过，之所以使用嵌套类的另一个原因是达到底层实现隐藏的目的。为了实现这种目的，我们需要在另一个头文件中定义该嵌套类，而只在外围类中前向声明这个嵌套类即可。当然，在外围类外面定义这个嵌套类时，应该使用外围类进行限定。使用时，只需要在外围类的实现文件中包含这个头文件即可。

另外，嵌套类可以直接引用外围类的静态成员、类型名和枚举成员，即使这些是private的。

下面是一个例子，
<pre>
//nestclass.h
#ifndef NESTCLASS_H_
#define NESTCLASS_H_
class A
{
public:
    A();
    ~A();
    void operate();
private:
    class B;
    B* m_b;
};
#endif


//nestclass.cpp
#include "nestclass.h"
#include <iostream>
using namespace std;
class A::B
{
public:
    B(){}
    ~B(){}
    void operate()
    {
        cout<<"B operate!"<<endl;
    }
};
A::A()
{
}
A::~A()
{
}
void A::operate()
{
    m_b = new B;
    cout<<"A operate!"<<endl;
    m_b->operate();
}


//main.cpp
#include "nestclass.h"
void main()
{
    A a;
    a.operate();
}
</pre>


